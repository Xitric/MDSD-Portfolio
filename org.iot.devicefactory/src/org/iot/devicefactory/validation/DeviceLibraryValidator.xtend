/*
 * generated by Xtext 2.20.0
 */
package org.iot.devicefactory.validation

import java.util.HashSet
import org.eclipse.xtext.validation.Check
import org.iot.devicefactory.deviceLibrary.BaseSensor
import org.iot.devicefactory.deviceLibrary.Board
import org.iot.devicefactory.deviceLibrary.DeviceLibraryPackage.Literals
import org.iot.devicefactory.deviceLibrary.Library
import org.iot.devicefactory.deviceLibrary.OverrideSensor
import org.iot.devicefactory.deviceLibrary.Sensor

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.iot.devicefactory.util.DeviceLibraryUtils.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DeviceLibraryValidator extends AbstractDeviceLibraryValidator {
	
	public static val ILLEGAL_PACKAGE = "org.iot.devicefactory.deviceLibrary.ILLEGAL_PACKAGE"
	public static val INCORRECT_PACKAGE = "org.iot.devicefactory.deviceLibrary.INCORRECT_PACKAGE"
	public static val INHERITANCE_CYCLE = "org.iot.devicefactory.deviceLibrary.INHERITANCE_CYCLE"
	public static val DUPLICATE_SENSOR = "org.iot.devicefactory.deviceLibrary.DUPLICATE_SENSOR"
	public static val NON_OVERRIDING_SENSOR = "org.iot.devicefactory.deviceLibrary.NON_OVERRIDING_SENSOR"
	
	@Check
	def validatePackage(Library library) {
		val segments = library.eResource.URI.segments
		
		if (segments.get(0) != "resource" || segments.get(2) != "src") {
			error("A board library must be located inside the src folder of an Eclipse project", Literals.LIBRARY__NAME)
		} else if(segments.length == 4) {
			if (library.name !== null) {
				error("There cannot be a package declaration in library files located outside a package", Literals.LIBRARY__NAME, ILLEGAL_PACKAGE)
			}
		} else {
			val expectedPackage = segments.subList(3, segments.length - 1).join(".")
			if (library.name != expectedPackage) {
				error('''Incorrect package name, expected «expectedPackage»''', Literals.LIBRARY__NAME, INCORRECT_PACKAGE, expectedPackage)
			}
		}
	}
	
	@Check
	def validateNoInheritanceCycles(Board board) {
		val known = new HashSet<Board>()
		var current = board
		while (current !== null) {
			if (known.contains(current)) {
				error("Inheritance cycles are not allowed", Literals.BOARD__PARENT, INHERITANCE_CYCLE)
				return
			}
			
			known.add(current)
			current = current.parent
		}
	}
	
	@Check
	def validateNoDuplicateBoards(Board board) {
		val library = board.getContainerOfType(Library)
		if (library.boards.takeWhile[it !== board].exists[name == board.name]) {
			error("Duplicate board names are not allowed. Choose a unique name", Literals.BOARD__NAME)
		}
	}
	
	@Check
	def validateNoDuplicateSensors(Sensor sensor) {
		val board = sensor.getContainerOfType(Board)
		if (board.sensors.takeWhile[it !== sensor].exists[it.name == sensor.name]) {
			error('''Duplicate sensor definition «sensor.name» in same board''', Literals.SENSOR__NAME, DUPLICATE_SENSOR)
		}
	}
	
	@Check
	def validateChildSensorsOverride(BaseSensor sensor) {
		val board = sensor.getContainerOfType(Board)
		if (board.parent.allHierarchySensors.exists[name == sensor.name]) {
			error('''Redeclared sensor «sensor.name» must override inherited definition from parent''',
				Literals.SENSOR__NAME, NON_OVERRIDING_SENSOR
			)
		}
	}
	
	@Check
	def validateLegalOverride(OverrideSensor sensor) {
		val board = sensor.getContainerOfType(Board)
		if (! board.parent.allHierarchySensors.exists[name == sensor.name]) {
			error('''No such sensor «sensor.name» to override from parent''', Literals.SENSOR__NAME)
		}
	}
}
