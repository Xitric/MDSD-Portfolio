/*
 * generated by Xtext 2.20.0
 */
package org.iot.devicefactory.validation

import java.util.HashSet
import org.eclipse.xtext.validation.Check
import org.iot.devicefactory.deviceLibrary.BaseSensor
import org.iot.devicefactory.deviceLibrary.Board
import org.iot.devicefactory.deviceLibrary.DeviceLibraryPackage.Literals
import org.iot.devicefactory.deviceLibrary.Library
import org.iot.devicefactory.deviceLibrary.OverrideSensor
import org.iot.devicefactory.deviceLibrary.Sensor

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.iot.devicefactory.util.LibraryUtils.*

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DeviceLibraryValidator extends AbstractDeviceLibraryValidator {
	
	public static val INHERITANCE_CYCLE = "org.iot.devicefactory.deviceLibrary.INHERITANCE_CYCLE"
	public static val DUPLICATE_SENSOR = "org.iot.devicefactory.deviceLibrary.DUPLICATE_SENSOR"
	public static val NON_OVERRIDING_SENSOR = "org.iot.devicefactory.deviceLibrary.NON_OVERRIDING_SENSOR"
	
	@Check
	def validateNoInheritanceCycles(Board board) {
		val known = new HashSet<Board>()
		var current = board
		while (current !== null) {
			if (known.contains(current)) {
				error("Inheritance cycles are not allowed", Literals.BOARD__PARENT, INHERITANCE_CYCLE)
				return
			}
			
			known.add(current)
			current = current.parent
		}
	}
	
	@Check
	def validateNoDuplicateBoards(Board board) {
		val library = board.getContainerOfType(Library)
		if (library.boards.takeWhile[it !== board].exists[name == board.name]) {
			error("Duplicate board names are not allowed. Choose a unique name", Literals.BOARD__NAME)
		}
	}
	
	@Check
	def validateNoDuplicateBaseSensors(BaseSensor sensor) {
		val board = sensor.getContainerOfType(Board)
		if (board.sensors.takeWhile[it !== sensor].exists[it.asBaseSensor.name == sensor.name]) {
			error('''Duplicate sensor definition «sensor.name» in same board''', Literals.BASE_SENSOR__NAME, DUPLICATE_SENSOR)
		}
	}
	
	@Check
	def validateNoDuplicateOverrideSensors(OverrideSensor sensor) {
		val board = sensor.getContainerOfType(Board)
		if (board.sensors.takeWhile[it !== sensor].exists[it.asBaseSensor.name == sensor.asBaseSensor.name]) {
			error('''Duplicate sensor definition «sensor.asBaseSensor.name» in same board''', Literals.OVERRIDE_SENSOR__PARENT, DUPLICATE_SENSOR)
		}
	}
	
	@Check
	def validateChildSensorsOverride(BaseSensor sensor) {
		var parent = sensor.getContainerOfType(Board).parent
		
		while (parent !== null) {
			for (Sensor parentSensor: parent.sensors) {
				if (parentSensor.asBaseSensor.name == sensor.name) {
					error('''Redeclared sensor «sensor.name» must override inherited definition from «parent.name»''',
						Literals.BASE_SENSOR__NAME, NON_OVERRIDING_SENSOR
					)
					return
				}
			}
			parent = parent.parent
		}
	}
}
