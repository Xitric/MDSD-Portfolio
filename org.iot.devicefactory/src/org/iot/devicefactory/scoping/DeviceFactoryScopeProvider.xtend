/*
 * generated by Xtext 2.20.0
 */
package org.iot.devicefactory.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.iot.devicefactory.common.CommonPackage
import org.iot.devicefactory.deviceFactory.ChildDevice
import org.iot.devicefactory.deviceFactory.Cloud
import org.iot.devicefactory.deviceFactory.Data
import org.iot.devicefactory.deviceFactory.Device
import org.iot.devicefactory.deviceFactory.DeviceFactoryPackage.Literals
import org.iot.devicefactory.deviceFactory.Fog
import org.iot.devicefactory.deviceFactory.Sensor
import org.iot.devicefactory.deviceLibrary.Board
import org.iot.devicefactory.util.DeviceLibraryUtils

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.iot.devicefactory.util.CommonUtils.*
import static extension org.iot.devicefactory.util.DeviceFactoryUtils.*
import org.iot.devicefactory.deviceFactory.Transformation

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class DeviceFactoryScopeProvider extends AbstractDeviceFactoryScopeProvider {
	
	override getScope(EObject context, EReference reference) {
		switch reference {
			case Literals.BASE_SENSOR__DEFINITION:
				context.sensorDefinitionScope
			case Literals.OVERRIDE_SENSOR__PARENT:
				context.parentSensorScope
			case CommonPackage.Literals.REFERENCE__VARIABLE:
				context.referenceVariableScope
			case Literals.TRANSFORMATION__PROVIDER:
				context.transformationDatas
			default:
				super.getScope(context, reference)
		}
	}
	
	private def IScope getSensorDefinitionScope(EObject context) {
		context.getContainerOfType(Device).board.boardSensorScope
	}
	
	private def IScope getBoardSensorScope(Board board) {
		if (board === null || board.eIsProxy) {
			IScope.NULLSCOPE
		} else {
			Scopes.scopeFor(board.sensors, QualifiedName.wrapper[DeviceLibraryUtils.getName(it)], board.parent.boardSensorScope)
		}
	}
	
	private def IScope getParentSensorScope(EObject context) {
		val device = context.getContainerOfType(Device)
		switch device {
			ChildDevice: device.parent.deviceSensorScope
			default: IScope.NULLSCOPE
		}
	}
	
	private def IScope getDeviceSensorScope(Device device) {
		val outerScope = switch device {
			ChildDevice: device.parent.deviceSensorScope
			default: IScope.NULLSCOPE
		}
		
		Scopes.scopeFor(device.sensors.filter[name !== null], QualifiedName.wrapper[name], outerScope)
	}
	
	private def IScope getReferenceVariableScope(EObject context) {
		val expressionScope = context.variables
		if (expressionScope.empty) {
			val sensor = context.getContainerOfType(Sensor)
			if (sensor !== null) {
				Scopes.scopeFor(sensor.variables)
			} else {
				val transformation = context.getContainerOfType(Transformation)
				Scopes.scopeFor(transformation.variables.variables)
			}
		} else {
			Scopes.scopeFor(expressionScope)
		}
	}
	
	private def IScope getTransformationDatas(EObject context) {
		var scope = context.eContainer.getContainerOfType(Cloud)?.getOutputDefinitionsFrom(Device, Fog)
		if (scope === null) {
			scope = context.eContainer.getContainerOfType(Fog)?.getOutputDefinitionsFrom(Device)
			if (scope === null) {
				return IScope.NULLSCOPE
			}
			return Scopes.scopeFor(scope)
		}
		return Scopes.scopeFor(scope)
	}
	
	def private Iterable<Data> getOutputDefinitionsFrom(EObject context, Class<? extends EObject>... types) {
		types.flatMap [
			context.getSiblingsOfType(it).allContents.filter(Data).toIterable
		]
	}
}
