/*
 * generated by Xtext 2.20.0
 */
package org.iot.devicefactory.formatting2

import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.ITextReplacer
import org.eclipse.xtext.formatting2.ITextReplacerContext
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.iot.devicefactory.deviceLibrary.BaseSensor
import org.iot.devicefactory.deviceLibrary.Board
import org.iot.devicefactory.deviceLibrary.DeviceLibraryPackage.Literals
import org.iot.devicefactory.deviceLibrary.I2C
import org.iot.devicefactory.deviceLibrary.Library
import org.iot.devicefactory.deviceLibrary.OverrideSensor
import org.iot.devicefactory.deviceLibrary.Pin
import org.iot.devicefactory.deviceLibrary.Preprocess
import org.iot.devicefactory.deviceLibrary.SensorInput

class DeviceLibraryFormatter extends CommonFormatter {

	def dispatch void format(Library library, extension IFormattableDocument document) {
		library.boards.forEach[format]
	}

	def dispatch void format(Board board, extension IFormattableDocument document) {
		board.regionFor.keyword("define").prepend[noSpace]
		board.regionFor.keyword("board").surround[oneSpace]
		
		if (board.parent === null) {
			board.regionFor.feature(Literals.BOARD__NAME).append[newLine]
		} else {
			board.regionFor.feature(Literals.BOARD__PARENT).append[newLine]
		}
		
		board.interior[indent]
		board.sensors.forEach[format]
	}
	
	def dispatch void format(BaseSensor baseSensor, extension IFormattableDocument document) {
		baseSensor.regionFor.keyword("sensor").append[oneSpace]
		baseSensor.input.format
		
		if (baseSensor.preprocess !== null) {
			baseSensor.input.append[newLine]
			
			baseSensor.interior[indent]
			baseSensor.preprocess.format
		}
		
		baseSensor.append[setNewLines(2, 2, 2)]
	}
	
	def dispatch void format(OverrideSensor overrideSensor, extension IFormattableDocument document) {
		overrideSensor.regionFor.keyword("override").append[oneSpace]
		overrideSensor.regionFor.keyword("sensor").append[oneSpace]
		
		if (overrideSensor.preprocess !== null) {
			overrideSensor.regionFor.feature(Literals.OVERRIDE_SENSOR__PARENT).append[newLine]
			
			overrideSensor.interior[indent]
			overrideSensor.preprocess.format
		}
		
		overrideSensor.append[setNewLines(2, 2, 2)]
	}
	
	def dispatch void format(Pin pin, extension IFormattableDocument document) {
		pin.formatInput("pin", document)
		pin.regionFor.keywords(",").forEach[prepend[noSpace].append[oneSpace]]
	}
	
	def dispatch void format(I2C i2c, extension IFormattableDocument document) {
		i2c.formatInput("i2c", document)
		
		val addressRegion = i2c.regionFor.feature(Literals.I2C__ADDRESS)
		document.addReplacer(new AddressReplacer(addressRegion))
	}
	
	private def formatInput(SensorInput sensorInput, String keyword, extension IFormattableDocument document) {
		sensorInput.regionFor.keyword(keyword).prepend[oneSpace].append[noSpace]
		
		sensorInput.regionFor.keyword("(").surround[noSpace]
		sensorInput.regionFor.keyword(")").prepend[noSpace].append[oneSpace]
		
		sensorInput.regionFor.keyword("as").surround[oneSpace]
		
		sensorInput.variables.format
	}
	
	def dispatch void format(Preprocess preprocess, extension IFormattableDocument document) {
		preprocess.regionFor.keyword("preprocess").append[oneSpace]
		preprocess.pipeline.format
	}
	
	static class AddressReplacer implements ITextReplacer {
		
		final ISemanticRegion addressRegion
		
		new(ISemanticRegion addressRegion) {
			this.addressRegion = addressRegion
		}
		
		override createReplacements(ITextReplacerContext context) {
			val newAddress = addressRegion.text.toUpperCase.replaceFirst("X", "x")
			val replacement = addressRegion.replaceWith(newAddress)
			context.addReplacement(replacement)
			return context
		}
		
		override getRegion() {
			addressRegion
		}
	}
}
