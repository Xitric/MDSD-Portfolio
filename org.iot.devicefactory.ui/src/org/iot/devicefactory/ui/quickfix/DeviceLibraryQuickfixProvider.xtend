/*
 * generated by Xtext 2.20.0
 */
package org.iot.devicefactory.ui.quickfix

import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import org.iot.devicefactory.deviceLibrary.Board
import org.iot.devicefactory.deviceLibrary.DeviceLibraryFactory
import org.iot.devicefactory.deviceLibrary.Library
import org.iot.devicefactory.deviceLibrary.Sensor
import org.iot.devicefactory.validation.DeviceLibraryIssueCodes

import static extension org.eclipse.xtext.EcoreUtil2.*
import static extension org.iot.devicefactory.util.DeviceLibraryUtils.*

/**
 * Custom quickfixes.
 *
 * See https://www.eclipse.org/Xtext/documentation/310_eclipse_support.html#quick-fixes
 */
class DeviceLibraryQuickfixProvider extends CommonQuickfixProvider {

	@Fix(DeviceLibraryIssueCodes.ILLEGAL_PACKAGE)
	def removePackageName(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove package statement', 'Remove incorrect usage of package statement', null) [
			context |
			val document = context.xtextDocument
			//issue.lineNumber is 1-based
			val issueLineInfo = document.getLineInformation(issue.lineNumber - 1)
			document.replace(issueLineInfo.offset, issueLineInfo.length, "")
		]
	}

	@Fix(DeviceLibraryIssueCodes.INCORRECT_PACKAGE)
	def changePackageName(Issue issue, IssueResolutionAcceptor acceptor) {
		val expectedPackage = issue.data.get(0)
		acceptor.accept(issue, '''Change to '«expectedPackage»' ''', '''Change package name to «expectedPackage» to reflect package structure''', null) [
			element, context |
			(element as Library).name = expectedPackage
		]
	}
	
	@Fix(DeviceLibraryIssueCodes.DUPLICATE_SENSOR)
	def removeDuplicateSensor(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Remove duplicate sensor', 'A sensor can only be declared once per board. Remove duplicate definitions', null) [
			element, context |
			element.getContainerOfType(Board).sensors.remove(element)
		]
	}
	
	@Fix(DeviceLibraryIssueCodes.NON_OVERRIDING_SENSOR)
	def overrideParentSensor(Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, 'Override parent sensor', 'When redeclaring a sensor in a child board, it must override the definition from the parent', null) [
			element, context |
			val board = element.getContainerOfType(Board)
			val sensors = board.sensors
			val sensorIndex = sensors.indexOf(element)
			val parentSensor = (element as Sensor).parentSensor
			
			sensors.set(
				sensorIndex,
				DeviceLibraryFactory.eINSTANCE.createOverrideSensor() => [
					name = parentSensor.name
					preprocess = (element as Sensor).preprocess
				]
			)
		]
	}
}
